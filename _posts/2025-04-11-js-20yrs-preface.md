---
layout:       post
title:        "密码学原理笔记"
author:       "Kean"
header-style: text
catalog:      true
tags:
    - Web
    - JavaScript
---

# 古典密码

# 完美加密理论
## 完美保密定义

明文空间为 $\mathcal{M}$ 的加密方案 $(Gen, Enc, Dec)$ 是完善保密加密，当且仅当对于 $\mathcal{M}$ 上任意的概率分布，$\forall m \in \mathcal{M}, c \in \mathcal{C}$ 且 $\Pr[C=c] > 0$，有：

$$\Pr[M=m|C=c] = \Pr[M=m]$$

一个等价的公式：

$$\Pr[C=c|M=m] = \Pr[C=c]$$

## 完美不可区分性

明文空间为 $\mathcal{M}$ 的加密方案 (Gen, Enc, Dec) 是完善保密加密，当且仅当对于任意 $\mathcal{M}$ 的概率分布，每个 $m_0, m_1 \in \mathcal{M}$ 和每个 $c \in \mathcal{C}$，均有：

$$\Pr[C=c|M=m_0] = \Pr[C=c|M=m_1]$$

## 敌手不可区分性

这是完善保密加密的又一个等价定义。它基于一个涉及敌手 $\mathcal{A}$ 的实验，断言"$\mathcal{A}$ 不能区分出密文是来自哪个明文"，故称为敌手不可区分性。

考虑任意加密方案 $\Pi = (Gen, Enc, Dec)$，任意敌手为 $\mathcal{A}$。用 $PrivK^{eav}$ 表示一个给定 $\Pi$ 和 $\mathcal{A}$ 的实验。实验的定义如下：

窃听不可区分实验 $PrivK_{\mathcal{A},\Pi}^{eav}$：
1. 敌手 $\mathcal{A}$ 输出一对信息 $m_0, m_1 \in \mathcal{M}$
2. 由 Gen 产生一个随机密钥 $k$，并且从 0,1 里面随机选择一个比特 $b$。然后，计算密文 $c \leftarrow Enc_k(m_b)$ 交给 $\mathcal{A}$
3. $\mathcal{A}$ 输出一个比特 $b'$
4. 若 $b' = b$，定义实验的输出为 1；否则为 0。若输出为 1，记为 $PrivK_{\mathcal{A},\Pi}^{eav} = 1$，此时称 $\mathcal{A}$ 成功。

定义加密方案 $\Pi$ 的敌手优势为：

$$Adv_{\Pi,\mathcal{A}}^{eav} = \left|\Pr[PrivK_{\mathcal{A},\Pi}^{eav}=1] - \frac{1}{2}\right|$$

这个优势值衡量了敌手 $\mathcal{A}$ 在区分实验中的成功程度与随机猜测的差距。若优势接近于 0，说明敌手的成功概率接近于随机猜测的 1/2，即该方案对敌手来说是安全的。

一个加密方案 $\Pi$ 具有完善保密性，当且仅当对于任意敌手 $\mathcal{A}$，都有：

$$Adv_{\Pi,\mathcal{A}}^{eav} = 0$$

这意味着即使是计算能力无限的敌手，也无法在这个实验中做得比随机猜测更好。

实验过程解释：
1. 敌手首先选择两个明文 $m_0$ 和 $m_1$，这代表它想要区分的两种可能情况
2. 实验者随机选择一个比特 $b$，并加密对应的明文 $m_b$
3. 敌手观察密文后，需要猜测加密的是哪个明文（即猜测 $b$ 的值）
4. 如果猜对了（$b'=b$），敌手就在这次实验中获胜

## 香农定理

(香农定理) 设加密方案 (Gen, Enc, Dec) 的明文空间为 $\mathcal{M}$，且 $|K| = |M| = |C|$，则当且仅当下列条件成立时，此方案是完善保密加密：

1. Gen 产生任何密钥的概率都是 $1/|K|$
2. 对任意 $m \in \mathcal{M}, c \in \mathcal{C}$，存在唯一的密钥 $k \in \mathcal{K}$，使得 $Enc_k(m) = c$

注意：以上定义都是一种逻辑上的，数学上的对于明文安全的要求，但是实际上无法做到不被破解，完美保密定义只是一个好的加密方案的要求。

## 规约证明

这表明：如果存在算法 $\mathcal{A}$ 能破解方案 $\Pi$，就能构造算法 $\mathcal{A}'$ 解决问题X

- 具体例子：证明 PRG 的封闭性
  
  ![PRG规约证明示例](/images/PRG规约证明示例.png)

  问题：如果 $F(s)$ 是 PRG，那么 $G(s) = F(s) \oplus 1^{|n|}$ 是否也是 PRG？
  
  规约证明过程：
  1. 假设（困难问题）：区分 $F(s)$ 和随机串是困难的（因为 $F(s)$ 是PRG）
  2. 待证问题：证明区分 $G(s)$ 和随机串也是困难的
  3. 规约构造：
     - 假设存在区分器 $D$ 能有效区分 $G(s)$ 和随机串
     - 构造区分器 $D'$ 来区分 $F(s)$ 和随机串：
       1. $D'$ 接收输入 $in$（可能是 $r$ 或 $F(s)$）
       2. 计算 $in \oplus 1^n$
       3. 将结果输入给 $D$
       4. 输出 $D$ 的结果
  4. 矛盾：
     - 如果 $D$ 能成功区分 $G(s)$，那么 $D'$ 就能成功区分 $F(s)$
     - 但这与 $F(s)$ 是PRG的假设矛盾
  5. 结论：$G(s)$ 也必须是PRG

## 利用 PRG 构造定长加密方案

给定一个将 $n$ 比特扩展为 $l$ 比特的伪随机生成器 $G$，我们可以构造如下的定长加密方案 $\Pi = (Gen, Enc, Dec)$：

1. $Gen$: 输出一个随机密钥 $k \leftarrow \{0,1\}^n$
2. $Enc_k(m)$: 
   - 对于输入消息 $m \in \{0,1\}^l$
   - 计算 $r = G(k)$
   - 输出密文 $c = m \oplus r$
3. $Dec_k(c)$:
   - 计算 $r = G(k)$
   - 输出明文 $m = c \oplus r$

安全性证明：

1. 由于 $G$ 是伪随机生成器，$G(k)$ 的输出在计算上不可区分于随机字符串。

2. 构造如下D：
   
   ![窃听不可区分实验](/images/证明定长加密方案窃听安全.png)

   如图所示：
   区分伪随机性为难题假设，破解加密方案为规约的子函数。针对伪随机生成器 $G$ 的区分器 $D$ 
   以 $\mathcal{A}$ 为子函数，使得当 $\mathcal{A}$ 破解了 $\Pi$ 则 $D$ 可以区分出 $G$，
   与 $G$ 的伪随机性矛盾。注意这里我们用了符号 $\tilde{\Pi}$ 来表示 $\Pi$ 的一个变体，
   来刻画加密方案中可能使用了真随机串来加密。

3. 这说明该方案满足窃听不可区分性。

注意：该方案只能加密固定长度（$l$ 比特）的消息。

## 利用 PRG 构造变长加密方案

给定一个可变输出长度的伪随机生成器 $G$，我们可以构造如下的变长加密方案 $\Pi = (Gen, Enc, Dec)$：

1. $Gen$: 输出一个随机密钥 $k \leftarrow \{0,1\}^n$
2. $Enc_k(m)$: 
   - 对于输入消息 $m \in \{0,1\}^l$ ($l$ 为任意长度)
   - 计算 $r = G(k,l)$，其中 $r$ 的长度为 $l$ 比特
   - 输出密文 $c = m \oplus r$
3. $Dec_k(c)$:
   - 计算 $r = G(k,|c|)$
   - 输出明文 $m = c \oplus r$

安全性证明：

1. 首先，由于 $G$ 是可变输出长度的伪随机生成器，对于任意长度 $l$，$G(k,l)$ 的输出在计算上不可区分于随机字符串。

2. 在窃听不可区分实验中：
   - 敌手选择任意两个相同长度的消息 $m_0, m_1$
   - 挑战者随机选择 $b$，计算 $c = m_b \oplus G(k,|m_b|)$
   - 由于 $G$ 的输出是伪随机的，$c$ 在计算上不可区分于随机字符串
   - 因此敌手无法区分密文是来自 $m_0$ 还是 $m_1$

3. 这说明该方案满足窃听不可区分性，即在窃听者面前是安全的。

注意：这个构造方案的安全性依赖于所使用的伪随机生成器 $G$ 的安全性。如果 $G$ 是安全的，那么这个加密方案就是窃听安全的。

## 流密码
- 流密码的概念

  在密码学的文献里，前两节中介绍的加密方案通常被称为流密码。这是因为加密是通过首先生成伪随机位流，然后将该流与明文进行异或运算来实现的。

  人们对"流密码"一词是指生成流的算法（即伪随机生成器 G）还是指整个加密方案存在一些混淆。

  我们认为，最好使用流密码这个术语来指代生成伪随机流的算法，因此"安全"流密码应该满足可变输出长度伪随机生成器的定义。

- 流密码的实际应用状况

  实际应用中，有 RC4 等流密码方案。RC4 不太安全，LFSR 非常不安全。目前来看，主张采用分组密码来进行加密；如果一定要用流密码，一般用分组密码造一个流出来。

  RC4的安全性问题：
  - 存在偏差：生成的密钥流中某些字节组合出现的概率与理想情况不同
  - WEP协议中的应用暴露了严重漏洞：IV重用导致密钥流可被恢复
  - 存在相关密钥攻击：不同密钥间可能产生相关的密钥流
  
  关于IV重用问题：
  1. IV的作用
     - IV（初始化向量）是一个随机数，用于确保即使使用相同的密钥，每次加密产生的密文也不同
     - 在WEP中，完整的加密密钥是由IV和共享密钥串接而成
  
  2. IV重用的危险
     - 如果两次加密使用相同的IV和密钥，就会产生相同的密钥流
     - 设两个明文m1、m2，使用相同的密钥流k加密得到密文c1、c2：
       c1 = m1 ⊕ k
       c2 = m2 ⊕ k
     - 将两个密文异或：
       c1 ⊕ c2 = (m1 ⊕ k) ⊕ (m2 ⊕ k) = m1 ⊕ m2
     - 这样就泄露了两个明文的异或结果
  
  3. WEP中的问题
     - WEP使用24位IV，范围太小，容易重复
     - 繁忙的网络中，几小时内就可能发生IV重用
     - 攻击者可以通过收集大量数据包，找到使用相同IV的密文
  
  LFSR（线性反馈移位寄存器）的安全性问题：
  - 输出具有线性特征：由于其构造方式是线性的，输出序列可以通过线性代数方法预测
  - 周期性明显：序列最终会重复
  - 已知明文攻击：如果攻击者获得足够的明文-密文对，可以通过解线性方程组恢复内部状态

## 多重加密
- 多密文窃听实验
- 多密文窃听不可区分性
- 流密码安全多次加密方案
  
# CPA安全与CCA安全
## CPA安全
- 敌⼿对加密函数预⾔机（Oracle）访问：敌⼿以任意明⽂作为输⼊，可以从预⾔机得到对应密⽂。此处，密钥是已经提前⽣成的，因此能通过加密函数预言机得到密⽂，但仍对敌⼿保密

- CPA不可区分性实验 $PrivK_{\mathcal{A},\Pi}^{cpa}(n)$:

  ![CPA不可区分性实验](/images/CPA不可区分性实验.png)

  1. 生成密钥: $k \leftarrow Gen(1^n)$
  2. 敌手 $\mathcal{A}$ 可以访问加密预言机 $Enc_k(\cdot)$,输出两个等长消息 $m_0,m_1$
  3. 随机选择 $b \leftarrow \{0,1\}$,计算挑战密文 $c \leftarrow Enc_k(m_b)$ 给 $\mathcal{A}$
  4. $\mathcal{A}$ 继续可以访问加密预言机,最后输出猜测 $b'$
  5. 如果 $b'=b$,实验输出1,否则输出0

- CPA安全定义:加密方案 $\Pi$ 是CPA安全的,如果对任意PPT敌手 $\mathcal{A}$,存在可忽略函数 $negl$ 使得:
  $$\Pr[PrivK_{\mathcal{A},\Pi}^{cpa}(n)=1] \leq \frac{1}{2} + negl(n)$$

- CPA安全比窃听安全更强,因为:
  1. 敌手可以主动选择明文进行加密
  2. 敌手可以在获得挑战密文后继续进行加密查询
  3. 这更符合实际攻击场景,如敌手可能诱导受害者加密特定消息

## 构造CPA安全加密方案
- 伪随机函数（PRF）
  - 定义：一个PRF是一个函数族 $F$，对于每个密钥 $k$，$F_k$ 是一个从输入空间到输出空间的确定性函数
  - 性质：
    1. 给定输入 $x$，可以高效计算 $F_k(x)$
    2. 在计算上不可区分于随机函数

- 利用PRF构造CPA安全加密方案
  - 思想：引入非确定性，通过不对称性保留随机信息
- 伪随机排列(PRP)和分组密码
  - 伪随机排列(PRP)
    - 定义：一个PRP是一个密钥确定的双射函数族 $F$，对于每个密钥 $k$，$F_k$ 是一个置换（双射）
    - 性质：
      1. 给定输入 $x$，可以高效计算 $F_k(x)$
      2. 给定输出 $y$，可以高效计算 $F_k^{-1}(y)$
      3. 在计算上不可区分于随机置换
  
  - 强伪随机排列(Strong PRP)
    - 一个高效的、带密钥的置换 $F$ 是**强伪随机置换（Strong PRP）**，如果对于所有概率多项式时间（PPT）区分器 $D$，满足：
    \[
    \left| \Pr\left[D^{F_k(\cdot), F_k^{-1}(\cdot)}(1^n) = 1\right] - \Pr\left[D^{f(\cdot), f^{-1}(\cdot)}(1^n) = 1\right] \right| \leq \text{negl}(n),
    \]
    其中 $f$ 是从对 $n$ 比特字符串的所有置换集合中均匀随机选择的。
    - 这个表达式的解释：
      1. $D^{F_k(\cdot), F_k^{-1}(\cdot)}(1^n)$ 表示区分器 $D$ 可以访问 $F_k$ 的正向计算和逆向计算，即同时能调用加密和解密功能
      2. $D^{f(\cdot), f^{-1}(\cdot)}(1^n)$ 表示区分器 $D$ 可以访问随机选择的置换 $f$ 的正向和逆向计算
      3. 两个概率之差的绝对值表示区分器在这两种情况下输出1的概率差异
      4. 这个差异小于等于可忽略函数 $\text{negl}(n)$，意味着没有有效的算法能够区分真实的密钥置换和随机置换
      5. 与普通PRP的关键区别：区分器不仅可以查询正向计算结果，还可以查询逆向计算结果

在强伪随机置换(Strong PRP)定义中的表达式：

 \[
    \left| \Pr\left[D^{F_k(\cdot), F_k^{-1}(\cdot)}(1^n) = 1\right] - \Pr\left[D^{f(\cdot), f^{-1}(\cdot)}(1^n) = 1\right] \right| \leq \text{negl}(n),
    \]

"输出1"表示的是区分器D做出的一个特定决定，详细解释如下：

区分器D本质上是一个算法，它的目标是区分两种情况：

与真实的密钥化置换函数 $F_k$ 及其逆函数 $F_k^{-1}$ 交互
与随机选择的置换函数 $f$ 及其逆函数 $f^{-1}$ 交互
区分器D会通过提交查询并分析响应来尝试判断自己处于哪种情况。最终，D需要做出决定：

输出"1"：表示D认为它在与真实的密钥化置换函数 $F_k$ 交互
输出"0"：表示D认为它在与随机置换函数 $f$ 交互
因此，$\Pr\left[D^{F_k(\cdot), F_k^{-1}(\cdot)}(1^n) = 1\right]$ 表示的是：当D实际上与密钥化置换函数交互时，D正确地输出1的概率。

而 $\Pr\left[D^{f(\cdot), f^{-1}(\cdot)}(1^n) = 1\right]$ 表示的是：当D实际上与随机置换函数交互时，D错误地输出1的概率。

这个表达式要求这两个概率的差值绝对值不能超过可忽略函数 $\text{negl}(n)$，意味着没有有效的区分器能够可靠地区分这两种情况。如果差值很小，说明区分器D基本上无法区分是在与密钥化置换函数交互还是与真随机置换函数交互。

换句话说，输出1代表的事件是："区分器判定它正在与密钥化置换函数交互"，无论这个判断是否正确。
  - 分组密码就是PRP的实际实现
    - 分组密码对固定长度(如128位)的输入块进行加密
    - 著名的分组密码：AES、DES等
    - 分组密码被设计成近似PRP的行为

- 操作模式
  - 目的：将分组密码扩展成可以加密任意长度消息的加密方案
  - 常见操作模式：
    1. ECB模式(Electronic CodeBook)
       - 直接将消息分块加密
       - 不安全：相同的明文块会产生相同的密文块
    
    2. CBC模式(Cipher Block Chaining)
       ![CBC模式加密](/images/CBC模式加密.png)
       - 每个明文块与前一个密文块异或后再加密
       - 需要随机IV
       - 公式：$c_i = F_k(m_i \oplus c_{i-1})$，其中 $c_0 = IV$
       - 安全性分析：
         1. 如果IV是随机选择的，CBC模式可以实现CPA安全
         2. 如果IV是可预测的，CBC模式不是CPA安全的。下面给出两个具体的攻击例子：
         
         例1：考虑一个有状态的CBC模式变体，其中发送方每次加密时将IV加1（而不是随机选择）。
         攻击者 $\mathcal{A}$ 的策略：
         3. 查询加密预言机，输入消息 $m = 0^{n-1}\|1$，获得密文 $\langle IV,c \rangle$
         4. 如果IV是奇数，输出随机比特
         5. 如果IV是偶数：
            - 输出两个消息 $m_0 = 0^n$ 和任意 $m_1$
            - 获得挑战密文 $\langle IV+1,c' \rangle$
            - 如果 $c'=c$ 输出0，否则输出1
         
         分析：当IV为偶数时，$IV+1 = IV \oplus (0^{n-1}\|1)$。因此：
         $$c = F_k(IV \oplus m) = F_k(IV \oplus 0^{n-1}1 \oplus m \oplus 0^{n-1}1) = F_k((IV+1) \oplus m_0)$$
         
         所以如果加密的是 $m_0$，则 $c'=c$；如果加密的是 $m_1$，则 $c' \neq c$。
         攻击者成功概率为3/4，远大于随机猜测的1/2。

         例2：更一般地，当IV可预测时的攻击方法：
         6. 攻击者进行一次查询：
            - 假设当前IV为 $IV_{curr}$
            - 预测下一个IV为 $IV_{next}$
            - 选择消息 $m$ 进行查询，获得密文 $c$

         7. 构造两个消息：
            - $m_0 = m$
            - $m_1 = m \oplus IV_{curr} \oplus IV_{next}$

         8. 分析：
            - 如果加密 $m_0$：$c' = F_k(m_0 \oplus IV_{next}) = F_k(m \oplus IV_{next})$
            - 如果加密 $m_1$：
              $$\begin{aligned}
              c' &= F_k(m_1 \oplus IV_{next}) \\
                 &= F_k((m \oplus IV_{curr} \oplus IV_{next}) \oplus IV_{next}) \\
                 &= F_k(m \oplus IV_{curr}) \\
                 &= c
              \end{aligned}$$

         9. 判断：
            - 如果得到的挑战密文 $c' = c$，则加密的是 $m_1$
            - 如果 $c' \neq c$，则加密的是 $m_0$

         这个攻击的成功概率是1，证明了CBC模式在IV可预测时不是CPA安全的。
    
    3. CTR模式(Counter)
       - 加密计数器生成密钥流
       - 公式：$c_i = m_i \oplus F_k(IV\|ctr_i)$
       - 本质上将分组密码转化为流密码

  - 关系总结：
    1. PRP是理论基础，定义了理想的安全性质
    2. 分组密码是PRP的具体实现
    3. 操作模式是使用分组密码构建实用加密方案的方法

## CCA安全

### CCA不可区分性实验

CCA不可区分性实验 $\text{PrivK}^{\text{cca}}_{\mathcal{A}, \Pi}(n)$：

1. $k \leftarrow \text{Gen}(1^n)$。

2. 敌手$\mathcal{A}$获得输入$1^n$和预言机访问权限$\mathcal{A}^{\text{Enc}_k(\cdot)}$与$\mathcal{A}^{\text{Dec}_k(\cdot)}$，输出两个等长消息$m_0, m_1$。

3. $b \leftarrow \{0, 1\}$。$c \leftarrow \text{Enc}_k(m_b)$交给敌手$\mathcal{A}$。

4. $\mathcal{A}$继续拥有预言机访问权限**除了对$c$的访问**，输出$b'$。

5. 如果$b' = b$，则$\mathcal{A}$成功，$\text{PrivK}^{\text{cca}}_{\mathcal{A}, \Pi} = 1$，否则为$0$。

- CCA安全性分析示例一：
  考虑以下加密方案（Construction 5）：
  - 加密形式：$c = \langle r, F_k(r) \oplus m \rangle$，其中r是随机数，$F_k$是PRF
  - 解密形式：$m = c \oplus F_k(r)$

  攻击分析：
  1. 当攻击者获得密文$c = \langle r, F_k(r) \oplus m_b \rangle$后
  2. 如果攻击者构造一个新的密文$c'$，与$c$只相差一个比特
  3. 则解密结果$m' = c' \oplus F_k(r)$与原始消息$m_b$在对应的比特位上也会有差异
  
  这说明：
  - 密文的每个比特的修改都会直接反映在解密结果的对应比特上
  - 攻击者可以通过修改密文并观察解密结果来获取原始消息的信息
  - 因此这个方案不是CCA安全的
- CBC, OFB, CTR 模式的CCA安全性分析
  - 考虑对密文进行一位修改

  1. CBC模式不是CCA安全的：
     - 攻击方法：
       1. 获得密文 $c = (IV, c_1, c_2, ..., c_n)$
       2. 构造新密文 $c' = (IV, c_1', c_2, ..., c_n)$，其中 $c_1'$ 与 $c_1$ 只差一个比特
       3. 将 $c'$ 提交给解密预言机
       4. 解密结果分析：
          - 第一个明文块 $m_1'$ 会完全损坏
          - 第二个明文块 $m_2'$ 与原始明文 $m_2$ 只差一个比特
          - 通过观察 $m_2'$ 与 $m_2$ 的差异，可以推断出原始明文的信息
  
  2. OFB模式不是CCA安全的：
     - 攻击方法：
       1. 获得密文 $c = (IV, c_1, c_2, ..., c_n)$
       2. 修改任意密文块的一个比特，得到 $c'$
       3. 将 $c' 提交给解密预言机
       4. 解密结果分析：
          - 修改的比特位置会在对应明文块的相同位置发生翻转
          - 其他位置保持不变
          - 这种一一对应的关系使攻击者可以通过比较原始明文和修改后的明文来获取信息
  
  3. CTR模式不是CCA安全的：
     - 攻击方法：
       1. 获得密文 $c = (IV, c_1, c_2, ..., c_n)$
       2. 修改任意密文块的一个比特，得到 $c'$
       3. 将 $c' 提交给解密预言机
       4. 解密结果分析：
          - 与OFB模式类似，密文的修改会直接反映在明文中
          - 攻击者可以通过控制密文的修改来操纵解密结果
          - 这种可预测的行为违反了CCA安全性要求

  总结：
  1. 这些模式都允许攻击者通过修改密文并观察解密结果来获取原始明文的信息
  2. 在CCA攻击模型中，攻击者可以利用解密预言机来验证其对明文的猜测
  3. 要实现CCA安全，需要添加额外的机制（如MAC）来检测密文的完整性


构造一个满足多重加密安全但不是CPA安全的方案：

设 $F$ 是一个伪随机函数，构造加密方案 $\Pi = (Gen, Enc, Dec)$：

1. $Gen$：随机选择密钥 $k \leftarrow \{0,1\}^n$

2. $Enc_k(m)$：
   - 随机选择 $r \leftarrow \{0,1\}^n$
   - 输出密文 $(r, F_k(r) \oplus m)$

3. $Dec_k(r,c)$：
   - 输出 $m = F_k(r) \oplus c$

安全性分析：

1. 多重加密安全性：
   - 每次加密使用新的随机数r
   - $F_k(r)$ 的输出看起来是随机的（因为F是PRF）
   - 因此密文看起来是随机的，满足窃听安全

2. 不是CPA安全：
   - 攻击方法：
     1. 选择明文 $m_1$，获得密文 $(r_1, c_1)$
     2. 选择明文 $m_2 = m_1 \oplus c_1 \oplus F_k(r_1)$
     3. 如果得到的新密文使用了相同的 $r_1$，就能区分出是否加密了 $m_2$
   - 这说明方案在CPA攻击下是不安全的，因为攻击者可以利用之前的查询结果构造新的查询

### Padding Oracle Attack

- 填充预言机攻击示例：判断消息是否为空
  
  ![填充预言机攻击](/images/填充预言机攻击.png)

  攻击方法：
  1. 在单个块的CBC模式中，通过修改IV的首个字节，攻击者能够获知消息m是否为空
  2. 分析过程：
     - 如果m为空，则会添加一个完整的填充块{b}^b
     - PRP的输入为 $IV \oplus \{b\}^b$；设IV的首字节为x，则PRP的输入为 $(x \oplus b)\|\{\cdot\}^{b-1} \oplus \{b\}^{b-1}$
     - 将IV的首字节从x改成y，不改变c1，解密得到的PRP输入不变，而解密出的明文首字节一定不是b，这会触发填充错误
     - 如果上述尝试没有触发错误，说明消息非空

  3. 继续攻击：
     - 可以通过类似方法，修改IV的第二个字节来判断消息长度是否为1字节
     - 以此类推，可以获得消息的长度

  这种攻击说明：
  - padding oracle会泄露关于明文的信息
  - 即使只能知道解密是否成功，也可能导致安全问题
  - 在实现中应该避免泄露padding是否正确的信息

## 实践构造PRP
在前面的章节中，我们研究了如何使用伪随机排列来构建安全加密方案和消息认证码。然而，我们还没有研究的一个最重要的问题是伪随机排列是如何构建的，甚至它们是否存在！在下一章中，我们将从理论的角度研究这些问题，并展示可以基于相当弱的假设证明安全的伪随机排列的构造。在本章中，我们将重点介绍在实践中使用的相对启发式但效率更高的伪随机排列构造 - 称为分组密码。

### 分组密码

- 分组密码的基本概念
- 分组密码是一种对固定长度的数据块进行加密的对称密钥加密算法。
  - 常见的分组长度为64位或128位。分组密码通过一系列的置换和替换操作，将明文块转换为密文块。

- 混淆扩散网络
  - 目标：构造“简洁的”但看起来随机的排列
  - 思想：从许多较小的的随机排列（或者看起来随机）构造一个长度较大的随机排列F
  - 基础工作：
    设我们希望分组密码F具有128位的块长度。我们可以定义F如下：F的密钥k将指定16个随机置换$f_1, ..., f_{16}$，每个置换具有8位的块长度。给定输入$x \in \{0,1\}^{128}$，我们将其解析为16个连续的8位块$x_1, ..., x_{16}$，然后设置：
  
    $$F_k(x) = f_1(x_1) \cdot f_2(x_2) \cdot ... \cdot f_{16}(x_{16})$$

  - 我们（非正式地）说这些$f_i$引入了混淆到F中。

  - 公式如下：
    $$F_k(x) = f_1(x_1) \cdot ... \cdot f_{16}(x_{16})$$

  - 缺陷：F的这种定义方式导致了局部变化的输入只会影响局部的输出
    - 如果输入x和x'仅在第一位上不同，那么根据定义，F的输出Fk(x)和Fk(x')也仅在第一字节上不同。这是因为每个8位块的置换是独立的，输入的第一位变化只会影响第一个8位块的置换结果，而不会影响其他块的置换结果。
    - 如果F是一个真正的随机置换，那么输入的任何一位变化都应该对输出的所有字节产生影响。这种性质称为“雪崩效应”，是理想的加密函数所期望的特性。雪崩效应确保了输入的微小变化会导致输出的显著变化，从而增加了加密的安全性和不可预测性。
    - 因此，F的定义方式缺乏这种全局影响的特性，导致其不能被认为是伪随机的。
  - 改进：
    - 为了解决这个问题，引入了两个额外的步骤。
    - 首先，引入扩散步骤，通过置换或“混合”输出的比特来实现。
    - 其次，混淆/扩散步骤（称为一个轮）重复多次。
    - 反复使用混淆和扩散可确保输入中的任何小变化都会被混合并传播到输出的所有位。
    - 其结果是，输入的微小变化会对输出产生重大影响，就像人们对随机排列的预期一样。
    - 例如，一个两轮分组密码的操作如下：
      1. 首先，计算$x' := F_k(x)$。
      2. 然后，将$x'$的比特重新排列得到$x_1$。
      3. 接着，计算$x_1' := F_k(x_1)$。
      4. 最后，将$x_1'$的比特重新排列得到输出$x_2$。
    - 我们注意到，每轮中使用的函数$f_i$以及置换不需要相同。通常假设每轮中使用的混合置换是固定的（即，与密钥无关），但也可以引入依赖于密钥的置换。

### 单轮置换-置换网络攻击

- 单轮置换-置换网络攻击：设 $F$ 是一个单轮置换-置换网络。我们展示一种攻击方法：
  - 其中攻击者仅需一个随机选择的输入输出对 $(x, y)$，即可轻松得出密钥 $k$，使得 $y = F_k(x)$。

  - 攻击者从输出值 $y$ 开始，然后逆向计算混合置换和 S 盒。
  - 由于置换和 S 盒的规范是公开的，攻击者可以轻松计算出中间值，该中间值正好是 $x \oplus k$（假设主密钥在网络的唯一一轮中用作子密钥）。
  - 由于攻击者也有输入 $x$，因此可以立即推导出密钥 $k$。这因此是一个完全破解。


# MAC与CRHF

## 在网络通信环境中，可能会存在消息篡改


## MAC
### 安全MAC定义

敌手成功：如果输出的消息和标签通过了验证，并且输出的消息是从未向预言机查询过的新消息。

The message authentication experiment Macforge$_{\mathcal{A}, \Pi}(n)$:

1. $k \leftarrow \text{Gen}(1^n)$
2. $\mathcal{A}$ is given input $1^n$ and oracle access to $\text{Mac}_k(\cdot)$, and outputs $(m, t)$. $Q$ is the set of queries to its oracle.
3. $\text{Macforge}_{\mathcal{A}, \Pi}(n) = 1 \iff \text{Vrfy}_k(m, t) = 1 \land m \notin Q$.
### 构造安全MAC

以下是几种常用的MAC构造方法：

1. 基于PRF的MAC：
   - 最简单的MAC构造是直接使用PRF
   - $Gen$：选择随机密钥 $k$ 用于PRF $F$
   - $Mac_k(m)$：输出 $t = F_k(m)$
   - $Vrfy_k(m,t)$：检查 $t \stackrel{?}{=} F_k(m)$
   - 当消息长度固定时，这种构造是安全的
   - 对于任意长度消息，需要先使用抗碰撞哈希函数压缩消息

2. 基于CBC-MAC的构造：
   - 使用分组密码的CBC模式构造MAC
   - 流程：
     1. 消息分块：$m = m_1 \| m_2 \| ... \| m_l$
     2. 初始值：$t_0 = 0^n$
     3. 对每个块迭代：$t_i = F_k(t_{i-1} \oplus m_i)$
     4. 输出最终标签：$t = t_l$
   - 注意：基本CBC-MAC仅适用于固定长度消息，否则不安全
   - 可以通过双重加密最后一块或添加长度编码来支持变长消息

3. HMAC：
   - 基于哈希函数的MAC，即使哈希函数的抗碰撞性被攻破也保持安全
   - 定义：$HMAC_k(m) = H((k \oplus opad) \| H((k \oplus ipad) \| m))$
   - 其中$opad$和$ipad$是两个不同的填充常量


## CRHF

### HF定义

哈希函数是一种将任意长度消息映射为固定长度输出的函数。形式上，哈希函数族 $H$ 由两个算法组成：

1. **Gen**：一个概率算法，输出密钥 $s$
2. **H**：一个确定性算法，接收密钥 $s$ 和任意长度消息 $x$，输出固定长度值 $H^s(x)$

一个好的哈希函数应具备以下特性：
- 计算效率高
- 输出分布均匀
- 单向性：从输出反推输入在计算上不可行

### CRHF定义

抗碰撞哈希函数(CRHF)是一类特殊的哈希函数，要求敌手难以找到两个不同的消息映射到相同的哈希值。形式定义如下：

哈希函数族 $H$ 是抗碰撞的，当且仅当对于任何PPT敌手 $\mathcal{A}$，存在可忽略函数 $negl$ 使得：

$$\Pr[Hash-coll_{\mathcal{A},H}(n)=1] \leq negl(n)$$

其中哈希碰撞实验 $Hash-coll_{\mathcal{A},H}(n)$ 定义为：
1. 运行 $s \leftarrow Gen(1^n)$
2. 敌手 $\mathcal{A}$ 使用 $s$ 输出两个消息 $m, m'$
3. 如果 $m \neq m'$ 且 $H^s(m) = H^s(m')$，则实验输出1，否则输出0


## 构造CRHF

### MD变换

我们现在介绍一种称为 Merkle-Damgard 变换的重要方法，该方法在实践中广泛用于构建抗碰撞哈希函数。该方法可以将任何固定长度的哈希函数转换为成熟的哈希函数（即处理任意长度的输入的哈希函数），同时保持前者的抗碰撞属性（如果存在）。这意味着在设计抗碰撞哈希函数时，我们可以将注意力限制在固定长度的情况上。这反过来又使设计实用的抗碰撞哈希函数的工作变得容易得多。除了在实践中被广泛使用之外，Merkle-Damgard 变换从理论角度来看也很有趣，因为它意味着压缩单个位与压缩任意量一样容易（或一样困难）。

为了具体说明，我们考虑一种固定长度的抗碰撞哈希函数，它将输入压缩为一半长度；即输入长度为 $\ell'(n) = 2\ell(n)$，输出长度为 $\ell(n)$。在练习 4.14 中，你被要求将该构造推广到任意 $\ell' > \ell$。我们用 $(Gen, h)$ 表示固定长度的抗碰撞哈希函数，并利用它构造一个抗碰撞哈希函数 $(Gen, H)$，该函数将任意长度的输入映射到长度为 $\ell(n)$ 的输出。（$Gen$ 保持不变。）在许多文献中，固定长度的抗碰撞哈希函数被称为压缩函数（compression function）。Merkle-Damgard 变换定义如下：

定义 4.13：
设 $(Gen, h)$ 是一个固定长度的抗碰撞哈希函数，其输入长度为 $2\ell(n)$，输出长度为 $\ell(n)$。构造一个变长的哈希函数 $(Gen, H)$ 如下：

- **Gen**：保持不变。
- **H**：对于输入密钥 $s$ 和长度为 $L < 2^{\ell(n)}$ 的字符串 $x \in \{0,1\}^*$，执行以下步骤（设 $\ell = \ell(n)$）：
  1. 设 $B := \lceil \frac{L}{\ell} \rceil$（即 $x$ 被分成的块数）。用零填充 $x$，使其长度为 $\ell$ 的倍数。将填充后的结果解析为一系列 $\ell$-比特块 $x_1, \dots, x_B$。设 $x_{B+1} := L$，其中 $L$ 使用恰好 $\ell$ 比特编码。
  2. 设 $z_0 := 0^\ell$。
  3. 对于 $i = 1, \dots, B+1$，计算 $z_i := h^s(z_{i-1} \| x_i)$。
  4. 输出 $z_{B+1}$。

这句话 "设 $x_{B+1} := L$，其中 $L$ 使用恰好 $\ell$ 比特编码" 是指在Merkle-Damgård变换中添加一个额外的消息块，专门用于存储原始消息的长度信息。

详细解释：

$x_{B+1}$：这是在已分块的消息($x_1, x_2, ..., x_B$)之后添加的一个额外块，是第$(B+1)$个块

$L$：代表原始消息的字节长度，即未填充前消息的比特数

"$L$使用恰好$\ell$比特编码"：

这意味着我们将长度值$L$表示为一个$\ell$比特的二进制数
例如，如果$\ell = 32$，那么我们将$L$表示为一个32位的整数
如果原始消息长度为1000比特，则$L = 1000$，会被编码为00...01111101000(32位二进制)
这个编码后的值将作为最后一个消息块$x_{B+1}$
目的：

添加消息长度作为最后一个块是MD变换的关键安全特性
它防止长度扩展攻击(Length Extension Attack)
确保不同长度的消息产生不同的哈希值，即使它们的内容部分相同
例如，消息"abc"和"abc000"(假设0是填充)在没有长度编码的情况下可能产生相同的哈希值
为什么限制为$\ell$比特：

压缩函数h的输入长度固定为$2\ell$比特
因此长度值$L$需要正好占用$\ell$比特，以便与前一轮的输出$z_B$(也是$\ell$比特)连接后，形成压缩函数的完整输入
这个长度编码步骤增强了哈希函数的安全性，是Merkle-Damgård变换中确保消息唯一性的重要组成部分。

在Merkle-Damgård变换中，前一轮输出$z_B$是$\ell$比特的，这是由以下原因决定的：

1. 压缩函数的设计
在MD变换中，我们使用的压缩函数$h$的定义是：
输入长度为$2\ell(n)$比特
输出长度为$\ell(n)$比特
这意味着每次压缩函数$h$的调用都会将输入"压缩"到一半的长度
2. 迭代过程的分析
对于每一轮的计算：$z_i := h^s(z_{i-1} | x_i)$
设 $z_0 := 0^\ell$。
$z_{i-1}$是前一轮的输出，长度为$\ell$比特
$x_i$是当前的消息块，长度也为$\ell$比特
将它们连接后得到$z_{i-1} | x_i$，总长度为$2\ell$比特
压缩函数$h$接收这$2\ell$比特输入，输出$\ell$比特结果$z_i$
3. 具体到最后一轮
当我们计算第B+1轮（最后一轮）时：
$z_B$是第B轮的输出，长度为$\ell$比特
$x_{B+1}$是长度编码块，长度为$\ell$比特
将它们连接得到$z_B | x_{B+1}$，总长度为$2\ell$比特
压缩函数输出$z_{B+1}$，长度为$\ell$比特，这就是最终的哈希值
4. 为什么输出是$\ell$比特
这是由压缩函数$h$的定义决定的
在定义中明确说明：$(Gen, h)$是一个固定长度的抗碰撞哈希函数，其输入长度为$2\ell(n)$，输出长度为$\ell(n)$
因此每一轮的输出（包括$z_B$）都必然是$\ell$比特长
这种设计确保了整个过程中数据大小的一致性：每轮输出都是固定的$\ell$比特，与下一轮的消息块（也是$\ell$比特）连接后，正好形成压缩函数所需的$2\ell$比特输入。

这就是 Merkle-Damgard 变换。

MD变换安全性证明：
我们证明对于任意$s$，$H^s$中的碰撞会导致$h^s$中的碰撞。
令$x$和$x'$是两个不同的字符串，其长度分别为$L$和$L'$，且满足$H^s(x) = H^s(x')$。
令$x_1, \dots, x_B$是填充后的$x$的$B$个块，令$x'_1, \dots, x'_{B'}$是填充后的$x'$的$B'$个块。
回想一下，$x_{B+1} = L$，$x'_{B'+1} = L'$。有两种情况需要考虑：

1. **情况1：$L \neq L'$。**  
   在这种情况下，计算$H^s(x)$的最后一步是$z_{B+1} := h^s(z_B \| L)$，计算$H^s(x')$的最后一步是$z'_{B'+1} := h^s(z'_{B'} \| L')$。  
   由于$H^s(x) = H^s(x')$，因此$h^s(z_B \| L) = h^s(z'_{B'} \| L')$。  
   然而，$L \neq L'$，所以$z_B \| L$和$z'_{B'} \| L'$是两个不同的字符串，它们在$h^s$中发生了碰撞。

2. **情况2：$L = L'$。**  
   注意，这意味着$B = B'$且$x_{B+1} = x'_{B'+1}$。  
   令$z_i$和$z'_i$分别是在计算$H^s(x)$和$H^s(x')$过程中$x$和$x'$的中间哈希值。  
   由于$x \neq x'$但$|x| = |x'|$，因此必然存在至少一个索引$i$（其中$1 \leq i \leq B$）使得$x_i \neq x'_i$。  
   令$i^* \leq B + 1$是满足$z_{i^*-1} \| x_{i^*} \neq z'_{i^*-1} \| x'_{i^*}$的**最大**索引。  
   如果$i^* = B + 1$，那么$z_B \| x_{B+1}$和$z'_B \| x'_{B+1}$是两个不同的字符串，它们在$h^s$中发生了碰撞，因为  
   \[
   h^s(z_B \| x_{B+1}) = z_{B+1} = H^s(x) = H^s(x') = z'_{B+1} = h^s(z'_B \| x'_{B+1}).
   \]

   如果$i^* \leq B$，则$i^*$的最大性意味着$z_{i^*} = z'_{i^*}$。  
   因此，再次地，$z_{i^*-1} \| x_{i^*}$和$z'_{i^*-1} \| x'_{i^*}$是两个不同的字符串，它们在$h^s$中发生了碰撞。

### 通过PRP构造CRHF

PRP(伪随机排列)可以用于构造抗碰撞哈希函数。以下是一种基于Davies-Meyer构造的方法：

给定一个PRP族 $F$，其中每个 $F_k$ 是一个 $n$ 比特到 $n$ 比特的置换，我们可以构造一个压缩函数 $h$：

$$h(x,y) = F_x(y) \oplus y$$

其中：
- $x$ 是 $n$ 比特的第一个输入块
- $y$ 是 $n$ 比特的第二个输入块
- $\oplus$ 是按位异或操作

该构造的抗碰撞性源于以下原理：
1. 对于任意固定的 $y$，函数 $x \mapsto F_x(y) \oplus y$ 表现为随机函数
2. 要找到碰撞 $h(x_1,y_1) = h(x_2,y_2)$，敌手必须要么:
   - 找到 $(x_1,y_1) \neq (x_2,y_2)$ 使得 $F_{x_1}(y_1) \oplus y_1 = F_{x_2}(y_2) \oplus y_2$
   - 或破解PRP的安全性

这种构造可以与MD变换结合使用，形成完整的哈希函数族：
1. 使用Davies-Meyer构造作为压缩函数
2. 应用MD变换处理任意长度输入

## 哈希MAC

### HMAC

HMAC是一种基于哈希函数构造的消息认证码，广泛应用于网络安全协议中。其设计保证了即使底层哈希函数的抗碰撞性被破解，HMAC仍能保持安全。

HMAC的构造如下：

$$\text{HMAC}_K(m) = H((K \oplus \text{opad}) \| H((K \oplus \text{ipad}) \| m))$$

其中：
- $H$是底层哈希函数（如SHA-256）
- $K$是密钥（通常进行填充使其长度等于哈希函数的块长度）
- $\text{opad}$是外部填充常量（通常为0x5c重复）
- $\text{ipad}$是内部填充常量（通常为0x36重复）
- $\|$表示连接操作

HMAC的安全性基于以下假设：
1. 密钥$K$保持秘密
2. 哈希函数$H$可以近似为伪随机函数





# 公钥加密理论

## 公钥加密安全定义

公钥加密方案由三个算法组成：$(Gen, Enc, Dec)$

1. $Gen(1^n)$：产生一对密钥$(pk, sk)$，其中$pk$是公钥，$sk$是私钥
2. $Enc_{pk}(m)$：使用公钥$pk$加密消息$m$，输出密文$c$
3. $Dec_{sk}(c)$：使用私钥$sk$解密密文$c$，恢复明文$m$

公钥加密的主要安全定义有：

### CPA安全（选择明文攻击安全）

公钥加密的CPA安全通过以下实验定义：
1. 挑战者运行$Gen(1^n)$生成密钥对$(pk, sk)$，将$pk$交给敌手
2. 敌手可以自行使用$pk$进行多次加密，最后提交两个等长消息$m_0, m_1$
3. 挑战者随机选择$b \leftarrow \{0,1\}$，计算$c \leftarrow Enc_{pk}(m_b)$
4. 敌手收到$c$后输出猜测$b'$
5. 实验输出1当且仅当$b' = b$

如果对所有PPT敌手$\mathcal{A}$，存在可忽略函数$negl$使得：
$$\Pr[\text{PubK}_{\mathcal{A},\Pi}^{cpa}(n)=1] \leq \frac{1}{2} + negl(n)$$
则称该方案是CPA安全的。

### CCA安全（选择密文攻击安全）

CCA安全比CPA安全更强，定义如下：
1. 挑战者运行$Gen(1^n)$生成密钥对$(pk, sk)$，将$pk$交给敌手
2. 敌手可以访问解密预言机$Dec_{sk}(\cdot)$，最后提交两个等长消息$m_0, m_1$
3. 挑战者随机选择$b \leftarrow \{0,1\}$，计算挑战密文$c^* \leftarrow Enc_{pk}(m_b)$
4. 敌手收到$c^*$后可继续访问解密预言机（但不能查询$c^*$本身），最后输出猜测$b'$
5. 实验输出1当且仅当$b' = b$

如果对所有PPT敌手$\mathcal{A}$，存在可忽略函数$negl$使得：
$$\Pr[\text{PubK}_{\mathcal{A},\Pi}^{cca}(n)=1] \leq \frac{1}{2} + negl(n)$$
则称该方案是CCA安全的。

## 混合加密

混合加密是结合公钥加密和对称加密的一种实用方法，适用于加密大量数据的场景。

![混合加密](/images/混合加密.png)

基本流程：
1. 发送方使用随机生成的临时对称密钥$k$加密消息$m$
2. 使用接收方的公钥$pk$加密这个临时对称密钥$k$
3. 将加密后的对称密钥和加密后的消息一起发送

具体构造：
- $(Gen, Enc, Dec)$：公钥加密方案
- $(E, D)$：对称加密方案

混合加密方案$\Pi = (Gen, \overline{Enc}, \overline{Dec})$定义为：
- $Gen$：同原公钥加密方案
- $\overline{Enc}_{pk}(m)$：
  1. 选择随机对称密钥$k$
  2. 计算$c_1 \leftarrow Enc_{pk}(k)$
  3. 计算$c_2 \leftarrow E_k(m)$
  4. 输出密文$(c_1, c_2)$
- $\overline{Dec}_{sk}(c_1, c_2)$：
  1. 解密$k \leftarrow Dec_{sk}(c_1)$
  2. 输出$m \leftarrow D_k(c_2)$

优势：
1. 效率高：对称加密用于大量数据，公钥加密只处理短密钥
2. 安全性继承：如果公钥和对称加密方案都是安全的，混合方案也是安全的
## 基于陷门排列的公钥加密

## RSA问题与加密

RSA问题是一个基于大数分解困难的计算难题，它是RSA公钥密码体制安全性的基础。
### 重要推论

如果 $\gcd(e,\phi(N))=1$，那么函数 $f_e$ （将 x 映射到 $x^e \bmod N$ 的函数）是一个排列。

证明：
1. $f_e$ 的定义：$f_e(x) = x^e \bmod N$，其中 x ∈ $\mathbb{Z}_N^*$

2. 要证明 $f_e$ 是排列，需要证明它是双射（一一对应）：
   - 单射（注入）：不同的输入映射到不同的输出
   - 满射（满）：每个可能的输出都能由某个输入得到

3. 由于 $\gcd(e,\phi(N))=1$：
   - 根据扩展欧几里得算法，存在整数d使得：
     $ed ≡ 1 \pmod{\phi(N)}$
   - 这意味着存在整数k，使得：
     $ed = 1 + k\phi(N)$

4. 考虑函数 $f_d$：
   - 对任意 y = $f_e(x)$，计算 $f_d(y)$：
   - $f_d(y) = y^d = (x^e)^d = x^{ed} = x^{1+k\phi(N)} = x \cdot (x^{\phi(N)})^k$
   - 根据欧拉定理，对于 x ∈ $\mathbb{Z}_N^*$，有 $x^{\phi(N)} ≡ 1 \pmod{N}$
   - 所以 $f_d(y) ≡ x \pmod{N}$

5. 这说明：
   - $f_d$ 是 $f_e$ 的逆函数
   - 有逆函数意味着 $f_e$ 是双射
   - 因此 $f_e$ 是一个排列

这个推论说明了为什么在RSA中要求e与φ(N)互素：这保证了加密函数是一个排列，从而保证了每个密文都能唯一解密。

### RSA加密方案
- 密钥生成
  - 使用两个质数p,q相乘得模数N
  - 计算欧拉函数
  - 挑选公钥E（E是指数，通常选择65537）
  - 计算得到私钥D

### 安全要求

为使RSA问题足够困难，需要：

1. 素数 $p$ 和 $q$ 应该：
   - 足够大（通常至少1024位）
   - 大小相近但不相等
   - 满足一些额外的密码学要求

2. 公开指数 $e$ 应该：
   - 与 $\phi(N)$ 互素
   - 足够大以防止小指数攻击
   - 通常选择65537（第四个费马数）

3. 实践中的额外考虑：
   - 使用安全的密钥生成算法
   - 采取防护措施抵抗侧信道攻击
   - 正确实现填充方案

### 攻击"书本上的RSA"

- 如果 $N$ 很小，可以通过因式分解找到 $p$ 和 $q$
- 如果 $e$ 很小，可以通过小指数攻击找到 $d$
- 如果两个公钥的模数相同，可以通过分析RSA公钥的因子得到私钥并破解加密信息

## DH问题与加密
### 循环群与离散对数
### DH假设和应用
### Elgamal加密⽅案
### 椭圆曲线（ECC）加密方案


# 数字签名
## 数字签名定义

数字签名是公钥密码学中的基本原语，用于确保消息的认证性和完整性。一个数字签名方案由三个算法组成：$(Gen, Sign, Vrfy)$

1. $Gen(1^n)$：生成密钥对$(pk, sk)$，其中$pk$是验证密钥（公钥），$sk$是签名密钥（私钥）
2. $Sign_{sk}(m)$：使用签名密钥$sk$对消息$m$进行签名，输出签名$\sigma$
3. $Vrfy_{pk}(m, \sigma)$：使用验证密钥$pk$验证签名$\sigma$是否是消息$m$的有效签名，输出1(接受)或0(拒绝)

### 正确性

对于所有$(pk, sk) \leftarrow Gen(1^n)$和所有消息$m$，都有：
$$Vrfy_{pk}(m, Sign_{sk}(m)) = 1$$

### 存在性不可伪造(EUF)

数字签名的标准安全定义是存在性不可伪造性，通过以下签名伪造实验定义：

$Sig\text{-}forge_{\mathcal{A}, \Pi}(n)$：
1. 运行$Gen(1^n)$生成$(pk, sk)$，将$pk$交给敌手$\mathcal{A}$
2. $\mathcal{A}$可以访问签名预言机$Sign_{sk}(\cdot)$，记录查询集合$Q$
3. $\mathcal{A}$输出$(m^*, \sigma^*)$
4. 实验输出1当且仅当$Vrfy_{pk}(m^*, \sigma^*) = 1$且$m^* \notin Q$

如果对于所有PPT敌手$\mathcal{A}$，存在可忽略函数$negl$使得：
$$\Pr[Sig\text{-}forge_{\mathcal{A}, \Pi}(n) = 1] \leq negl(n)$$
则称该数字签名方案是存在性不可伪造的。

### 强不可伪造性

更强的安全定义是强不可伪造性，其中敌手不仅不能伪造新消息的签名，也不能为已查询过的消息生成新的有效签名。实验与EUF类似，但条件改为$(m^*, \sigma^*) \notin \{(m, Sign_{sk}(m)) | m \in Q\}$。

## 数字签名方案
### RSA数字签名
### 来自离散对数的数字签名
### 一次签名方案/理论构造安全签名方案
## 证书
##

# 密码协议
## 三次传递协议
## 中间人攻击 
## 互锁协议

